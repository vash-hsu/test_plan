General Test Plan Guideline
---
index
* [Testing Type](#testing_type)
 * [Functional Tests](#functional_tests)


---


# Testing Type

### Functional Tests

#### Grouping by Types

* BVT
* RAT: release acceptance test
* FAST: functioan acceptance test
* FET: force error test
* TOFT: task-oriented functional test
* SMOKE

#### common practice
* for a regular test run, as less test cases/steps as possible
 * i.e. 10 cases for 1 minutes is better than 100 cases for 10 minutes
* for a set of test cases, as much coverage as better
 * i.e. if test case A can cover test case B and C, then use A replace B+C.
* for a controlable input data, as smaller equivalent class as possible
 * i.e. for integer input, there are possible equivalent classes for input range  

| - | equivalent class | - |
|---|---|---|
| - | i < 0 | sometimes, negative number is used to indicate error |
| - | i == 0 | some logic use 0 as false and non-zero as true |
| - | i > 0 | the most common cases without touching integer overflow |
| - | i = MAX and then i++ | in case of overflow |
| - | i = MIN (negative) and then i-- | in case of overflow |

* clean and clear discription for test case
 * i.e. calculator for A + B = C

| IPO | Phase | Description | (optional) detail |  
|---|---|---|---|
| input | pre-condition | when both A and B are positive integer | a = 1 and b = 2 |  
| process | processing | we will get C returned after performing + | SUT return a+b |  
| output | post-condition | C should be equivalent to sum of &#124;A&#124; and &#124;B&#124; | c == 3, otherwise test failed |  

* for corner cases, FET (force-error) tests and other expensive test cases
 * (risk-based) use FMEA to force ranking test cases based on risk
 * (ROI-based) use defect density to evaluate when to stop testing
 * (coverage-based) use requirement/function/branch/condition coverage to evaluate completeness of testing


### Load Tests
* behavior of the system under a specific expected load

### Stress Tests
* upper limits of capacity within the system

### Soak Tests
* system can sustain the continuous expected load

### Spike Tests
* system can sustain a suddenly increasing load generated by a large number of traffic/transaction/users

### Isolation Tests
*Â previously detected system issue has been fixed by repeating a test execution that resulted in a system problem
* to verify the output of each one of those interfaces/subsystems precisely https://www.tutorialspoint.com/software_testing_dictionary/isolation_testing.htm



---

# Component of Test Case

## Product
* product name, project code, a.k.a. SUT (software under test)
* version (major, minor, build, revision)
* feature ID/topic, requirement mapping, function name
* platform: OS, browswer (the testing one and/or preferred one)

## Case
* test case ID, title, purpose, short description, type, scope of functions/requirements
* test steps, assumption (i.e. environment), expected result
* (tool assisting) creator/owner, timestamp of creation and updating

---


### Referece

##### Defect Density
* http://softwaretestingfundamentals.com/defect-density/

```
defect Density = [Number of Defects] / [Size, function points, lines of code]
```
##### Test Case
* http://www.360doc.com/content/10/0826/16/1698198_48958195.shtml

* https://dzone.com/articles/automated-performance-tests-in-jenkins-ci-environm
